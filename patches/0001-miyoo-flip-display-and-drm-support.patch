diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 162cc58c7..7f6ee67be 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -33,6 +33,7 @@
 #include <linux/regulator/consumer.h>
 
 #include <video/display_timing.h>
+#include <video/mipi_display.h>
 #include <video/of_display_timing.h>
 #include <video/videomode.h>
 
@@ -137,12 +138,30 @@ struct panel_desc {
 	int connector_type;
 };
 
+/**
+ * struct panel_dsi_cmd - one entry in a DSI init/exit sequence.
+ *
+ * Uses the Rockchip BSP format: [data_type, delay_ms, payload_len, payload…].
+ * data_type is the MIPI-DSI data-type ID (0x05, 0x15, 0x23, 0x29, 0x39).
+ */
+struct panel_dsi_cmd {
+	u8 type;	/* MIPI DSI data type */
+	u8 delay;	/* delay in ms after sending */
+	u8 len;		/* payload length */
+	const u8 *payload;
+};
+
 struct panel_desc_dsi {
 	struct panel_desc desc;
 
 	unsigned long flags;
 	enum mipi_dsi_pixel_format format;
 	unsigned int lanes;
+
+	const struct panel_dsi_cmd *init_cmds;
+	unsigned int num_init_cmds;
+	const struct panel_dsi_cmd *exit_cmds;
+	unsigned int num_exit_cmds;
 };
 
 struct panel_simple {
@@ -292,10 +311,24 @@ static void panel_simple_wait(ktime_t start_ktime, unsigned int min_ms)
 		msleep(ktime_to_ms(ktime_sub(min_ktime, now_ktime)) + 1);
 }
 
+static int panel_simple_dsi_send_cmds(struct drm_panel *panel,
+				      const struct panel_dsi_cmd *cmds,
+				      unsigned int num_cmds);
+
 static int panel_simple_disable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 
+	/* Send DSI exit commands if this is a DSI panel with an exit seq. */
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI) && dev_is_mipi_dsi(panel->dev)) {
+		const struct panel_desc_dsi *dsi_desc;
+
+		dsi_desc = container_of(p->desc, struct panel_desc_dsi, desc);
+		panel_simple_dsi_send_cmds(panel,
+					   dsi_desc->exit_cmds,
+					   dsi_desc->num_exit_cmds);
+	}
+
 	if (p->desc->delay.disable)
 		msleep(p->desc->delay.disable);
 
@@ -351,6 +384,7 @@ static int panel_simple_resume(struct device *dev)
 
 static int panel_simple_prepare(struct drm_panel *panel)
 {
+	struct panel_simple *p = to_panel_simple(panel);
 	int ret;
 
 	ret = pm_runtime_get_sync(panel->dev);
@@ -359,6 +393,120 @@ static int panel_simple_prepare(struct drm_panel *panel)
 		return ret;
 	}
 
+	/*
+	 * Send DSI init commands during prepare(), while the DSI host is
+	 * still in command mode (pre_enable).  The bridge ordering
+	 * (pre_enable_prev_first = true) guarantees that DSI mode_set
+	 * has already run and the host is in command mode.
+	 * Sending in enable() would be too late — DSI has switched to
+	 * video mode and the payload FIFO is shared with video data.
+	 */
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI) && dev_is_mipi_dsi(panel->dev)) {
+		const struct panel_desc_dsi *dsi_desc;
+
+		dsi_desc = container_of(p->desc, struct panel_desc_dsi, desc);
+		ret = panel_simple_dsi_send_cmds(panel,
+						 dsi_desc->init_cmds,
+						 dsi_desc->num_init_cmds);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * Send one DSI command, with up to @retries attempts.
+ * Between retries, sleep 5 ms to let the FIFO drain (in video mode,
+ * the payload FIFO is shared with the video stream and LP commands
+ * can only be sent during vertical blanking).
+ */
+static int panel_simple_dsi_send_one(struct mipi_dsi_device *dsi,
+				     const struct panel_dsi_cmd *cmd,
+				     int retries)
+{
+	int ret, attempt;
+
+	for (attempt = 0; attempt <= retries; attempt++) {
+		if (attempt)
+			usleep_range(5000, 10000);
+
+		switch (cmd->type) {
+		case MIPI_DSI_DCS_SHORT_WRITE:		/* 0x05 */
+			ret = mipi_dsi_dcs_write(dsi, cmd->payload[0],
+						 NULL, 0);
+			break;
+		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:	/* 0x15 */
+			ret = mipi_dsi_dcs_write(dsi, cmd->payload[0],
+						 &cmd->payload[1],
+						 cmd->len - 1);
+			break;
+		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM: /* 0x23 */
+		case MIPI_DSI_GENERIC_LONG_WRITE:	/* 0x29 */
+			ret = mipi_dsi_generic_write(dsi, cmd->payload,
+						     cmd->len);
+			break;
+		case MIPI_DSI_DCS_LONG_WRITE:		/* 0x39 */
+			ret = mipi_dsi_dcs_write_buffer(dsi, cmd->payload,
+							cmd->len);
+			break;
+		default:
+			ret = mipi_dsi_generic_write(dsi, cmd->payload,
+						     cmd->len);
+			break;
+		}
+
+		if (ret >= 0)
+			return 0;
+	}
+
+	return ret;
+}
+
+/*
+ * Send a batch of DSI commands (init or exit sequence) for DSI panels
+ * that need vendor-specific register programming.
+ *
+ * Called from panel_simple_enable() where the DSI link is up and the
+ * host can transfer LP commands (even while video mode is active,
+ * via VID_MODE_CFG_LP_CMD_EN).  Because the payload FIFO is shared
+ * with video traffic, a small inter-command delay (2 ms) is inserted
+ * to let the FIFO drain between transfers.  Commands that already
+ * specify a delay use that value instead.
+ */
+static int panel_simple_dsi_send_cmds(struct drm_panel *panel,
+				      const struct panel_dsi_cmd *cmds,
+				      unsigned int num_cmds)
+{
+	struct mipi_dsi_device *dsi;
+	unsigned int i;
+	int ret;
+
+	if (!cmds || !num_cmds)
+		return 0;
+
+	if (!IS_ENABLED(CONFIG_DRM_MIPI_DSI) || !dev_is_mipi_dsi(panel->dev))
+		return 0;
+
+	dsi = to_mipi_dsi_device(panel->dev);
+
+	for (i = 0; i < num_cmds; i++) {
+		const struct panel_dsi_cmd *cmd = &cmds[i];
+
+		ret = panel_simple_dsi_send_one(dsi, cmd, 3);
+		if (ret < 0) {
+			dev_err(panel->dev,
+				"failed to send DSI cmd[%u] type=0x%02x: %d\n",
+				i, cmd->type, ret);
+			return ret;
+		}
+
+		if (cmd->delay)
+			msleep(cmd->delay);
+		else
+			usleep_range(2000, 3000);
+	}
+
 	return 0;
 }
 
@@ -369,6 +517,12 @@ static int panel_simple_enable(struct drm_panel *panel)
 	if (p->desc->delay.enable)
 		msleep(p->desc->delay.enable);
 
+	/*
+	 * DSI init commands have already been sent in prepare() while
+	 * the host was in command mode.  Nothing else to do here —
+	 * drm_panel_enable() will turn on the backlight after we return.
+	 */
+
 	return 0;
 }
 
@@ -736,7 +890,6 @@ static struct panel_simple *panel_simple_probe(struct device *dev)
 		dev_err_probe(dev, err, "Could not find backlight\n");
 		goto disable_pm_runtime;
 	}
-
 	drm_panel_add(&panel->base);
 
 	return panel;
@@ -5603,6 +5756,145 @@ static struct platform_driver panel_simple_platform_driver = {
 	.shutdown = panel_simple_platform_shutdown,
 };
 
+/*
+ * Miyoo Flip 3.5" 640x480 MIPI-DSI panel (Fitipower EK79007-based controller).
+ * Requires a DSI init sequence to wake the panel and configure the controller.
+ * Sequence extracted from the Rockchip BSP device-tree (panel-init-sequence).
+ */
+static const struct drm_display_mode miyoo_flip_panel_mode = {
+	.clock = 32000,
+	.hdisplay = 640,
+	.hsync_start = 640 + 150,
+	.hsync_end = 640 + 150 + 120,
+	.htotal = 640 + 150 + 120 + 120,
+	.vdisplay = 480,
+	.vsync_start = 480 + 20,
+	.vsync_end = 480 + 20 + 6,
+	.vtotal = 480 + 20 + 6 + 12,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+/* Init sequence payload data — extracted from BSP panel-init-sequence */
+static const u8 miyoo_cmd_sleep_out[] = { 0x11 };
+static const u8 miyoo_cmd_display_on[] = { 0x29 };
+static const u8 miyoo_cmd_b9[] = { 0xB9, 0xF1, 0x12, 0x87 };
+static const u8 miyoo_cmd_b2[] = { 0xB2, 0x78, 0x04, 0x70 };
+static const u8 miyoo_cmd_b3[] = { 0xB3, 0x10, 0x10, 0x28, 0x28, 0x03, 0xFF,
+				    0x00, 0x00, 0x00, 0x00 };
+static const u8 miyoo_cmd_b4[] = { 0xB4, 0x80 };
+static const u8 miyoo_cmd_b5[] = { 0xB5, 0x0A, 0x0A };
+static const u8 miyoo_cmd_b8[] = { 0xB8, 0x26, 0x22, 0xF0, 0x13 };
+static const u8 miyoo_cmd_ba[] = { 0xBA, 0x31, 0x81, 0x05, 0xF9, 0x0E, 0x0E,
+				    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x44, 0x25, 0x00, 0x91, 0x0A, 0x00,
+				    0x00, 0x01, 0x4F, 0x01, 0x00, 0x00, 0x37 };
+static const u8 miyoo_cmd_bc[] = { 0xBC, 0x47 };
+static const u8 miyoo_cmd_bf[] = { 0xBF, 0x02, 0x11, 0x00, 0x80, 0x04 };
+static const u8 miyoo_cmd_c0[] = { 0xC0, 0x73, 0x73, 0x50, 0x50, 0x00, 0x00,
+				    0x12, 0x73, 0x00 };
+static const u8 miyoo_cmd_c1[] = { 0xC1, 0x73, 0x00, 0x32, 0x32, 0x77, 0xF4,
+				    0x77, 0x77, 0xCC, 0xCC, 0xFF, 0xFF, 0x11,
+				    0x11, 0x00, 0x00, 0x32 };
+static const u8 miyoo_cmd_c7[] = { 0xC7, 0x10, 0x00, 0x0A, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0xED, 0xC5, 0x00, 0xA5 };
+static const u8 miyoo_cmd_c8[] = { 0xC8, 0x10, 0x40, 0x1E, 0x03 };
+static const u8 miyoo_cmd_cc[] = { 0xCC, 0x0B };
+static const u8 miyoo_cmd_e0[] = { 0xE0, 0x00, 0x05, 0x09, 0x29, 0x3C, 0x3F,
+				    0x3B, 0x37, 0x05, 0x0A, 0x0C, 0x10, 0x13,
+				    0x10, 0x13, 0x12, 0x1A, 0x00, 0x05, 0x09,
+				    0x29, 0x3C, 0x3F, 0x3B, 0x37, 0x05, 0x0A,
+				    0x0C, 0x10, 0x13, 0x10, 0x13, 0x12, 0x1A };
+static const u8 miyoo_cmd_e1[] = { 0xE1, 0x11, 0x11, 0x91, 0x00, 0x00, 0x00,
+				    0x00 };
+static const u8 miyoo_cmd_e3[] = { 0xE3, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B,
+				    0x00, 0x00, 0x00, 0x00, 0xFF, 0x04, 0xC0,
+				    0x10 };
+static const u8 miyoo_cmd_e9[] = { 0xE9, 0xC8, 0x10, 0x02, 0x00, 0x00, 0xB0,
+				    0xB1, 0x11, 0x31, 0x23, 0x28, 0x80, 0xB0,
+				    0xB1, 0x27, 0x08, 0x00, 0x04, 0x02, 0x00,
+				    0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00,
+				    0x00, 0x88, 0x88, 0xBA, 0x60, 0x24, 0x08,
+				    0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+				    0xBA, 0x71, 0x35, 0x18, 0x88, 0x88, 0x88,
+				    0x88, 0x88, 0x00, 0x00, 0x00, 0x01, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00 };
+static const u8 miyoo_cmd_ea[] = { 0xEA, 0x97, 0x0A, 0x82, 0x02, 0x03, 0x07,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81,
+				    0x88, 0xBA, 0x17, 0x53, 0x88, 0x88, 0x88,
+				    0x88, 0x88, 0x88, 0x80, 0x88, 0xBA, 0x06,
+				    0x42, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+				    0x23, 0x00, 0x00, 0x02, 0xA5, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const u8 miyoo_cmd_ef[] = { 0xEF, 0xFF, 0xFF, 0x01 };
+
+/* Display Off + Sleep In */
+static const u8 miyoo_cmd_display_off[] = { 0x28 };
+static const u8 miyoo_cmd_sleep_in[] = { 0x10 };
+
+#define MIYOO_CMD(_type, _delay, _payload) \
+	{ .type = (_type), .delay = (_delay), .len = sizeof(_payload), \
+	  .payload = (_payload) }
+
+static const struct panel_dsi_cmd miyoo_flip_init_cmds[] = {
+	MIYOO_CMD(MIPI_DSI_DCS_SHORT_WRITE, 250, miyoo_cmd_sleep_out),
+	MIYOO_CMD(MIPI_DSI_DCS_SHORT_WRITE, 32,  miyoo_cmd_display_on),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_b9),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_b2),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_b3),
+	MIYOO_CMD(MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM, 0, miyoo_cmd_b4),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_b5),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_b8),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_ba),
+	MIYOO_CMD(MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM, 0, miyoo_cmd_bc),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_bf),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_c0),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_c1),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_c7),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_c8),
+	MIYOO_CMD(MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM, 0, miyoo_cmd_cc),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_e0),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_e1),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_e3),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_e9),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_ea),
+	MIYOO_CMD(MIPI_DSI_GENERIC_LONG_WRITE, 0, miyoo_cmd_ef),
+};
+
+static const struct panel_dsi_cmd miyoo_flip_exit_cmds[] = {
+	MIYOO_CMD(MIPI_DSI_DCS_SHORT_WRITE, 0, miyoo_cmd_display_off),
+	MIYOO_CMD(MIPI_DSI_DCS_SHORT_WRITE, 0, miyoo_cmd_sleep_in),
+};
+
+static const struct panel_desc_dsi miyoo_flip_panel = {
+	.desc = {
+		.modes = &miyoo_flip_panel_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 68,
+			.height = 121,
+		},
+		.delay = {
+			.prepare = 200,   /* BSP: init-delay-ms after power-on / reset */
+			.enable = 200,    /* BSP: enable-delay-ms before backlight on */
+			.disable = 20,    /* BSP: disable-delay-ms */
+			.unprepare = 20,  /* BSP: unprepare-delay-ms */
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 2,
+	.init_cmds = miyoo_flip_init_cmds,
+	.num_init_cmds = ARRAY_SIZE(miyoo_flip_init_cmds),
+	.exit_cmds = miyoo_flip_exit_cmds,
+	.num_exit_cmds = ARRAY_SIZE(miyoo_flip_exit_cmds),
+};
+
 static const struct drm_display_mode auo_b080uan01_mode = {
 	.clock = 154500,
 	.hdisplay = 1200,
@@ -5779,6 +6071,9 @@ static const struct panel_desc_dsi osd101t2045_53ts = {
 
 static const struct of_device_id dsi_of_match[] = {
 	{
+		.compatible = "miyoo,flip-panel",
+		.data = &miyoo_flip_panel
+	}, {
 		.compatible = "auo,b080uan01",
 		.data = &auo_b080uan01
 	}, {
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
index 3099408e9..a9a7590bb 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
@@ -210,7 +210,8 @@ static int rockchip_drm_bind(struct device *dev)
 	component_unbind_all(dev, drm_dev);
 err_free:
 	drm_dev_put(drm_dev);
-	return ret;
+	/* Use dev_err_probe so deferred-probe dump shows reason (avoid "reason unknown"). */
+	return dev_err_probe(dev, ret, "display component bind failed\n");
 }
 
 static void rockchip_drm_unbind(struct device *dev)
